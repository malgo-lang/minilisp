module Main = {
  module {..} = import Builtin;
  module {..} = import Prelude;

  id : a -> a;
  id = { x -> x };

  foldl : (a -> b -> a) -> a -> List b -> a;
  foldl =
    { _ z Nil -> z
    | f z (Cons x xs) -> foldl f (f z x) xs
    };

  foreign import char_ord : Char# -> Int32#;

  ord : Char -> Int32;
  ord = { Char# c -> Int32# (char_ord c) };

  cond : List (Bool, {a}) -> a;
  cond =
    { Nil -> panic "no branch"
    | Cons (True, x) _ -> !x
    | Cons (False, _) xs -> cond xs
    };

  mapList : (a -> b) -> List a -> List b;
  mapList =
    { _ Nil -> Nil
    | f (Cons x xs) -> Cons (f x) (mapList f xs)
    };

  data Maybe a = Nothing | Just a;

  foreign import string_cons : Char# -> String# -> String#;

  stringCons : Char -> String -> String;
  stringCons = { (Char# c) (String# str) -> String# (string_cons c str) };

  listToString : List Char -> String;
  listToString =
    { Nil -> ""
    | Cons c cs -> stringCons c (listToString cs)
    };

  headString : String -> Maybe Char;
  headString = { str ->
    if (eqString str "")
      { Nothing }
      { Just (atString 0L str) }
  };

  tailString : String -> String;
  tailString = { str ->
    if (eqString str "")
      { str }
      { substring str 1L (lengthString str) }
  };

  takeWhileString = { pred str ->
    headString str
      |> { Nothing -> str
         | Just c ->
             if (pred c)
               { stringCons c (takeWhileString pred (tailString str)) }
               { "" }
      }
  };

  dropWhileString = { pred str ->
    headString str
      |> { Nothing -> str
         | Just c ->
             if (pred c)
               { dropWhileString pred (tailString str) }
               { str }
      }
  };

  foreign import is_digit : Char# -> Int32#;
  isDigit : Char -> Bool;
  isDigit = { Char# x -> isTrue# (is_digit x) };

  foreign import is_lower : Char# -> Int32#;
  isLower : Char -> Bool;
  isLower = { Char# x -> isTrue# (is_lower x) };

  foreign import is_alphanum : Char# -> Int32#;
  isAlphanum : Char -> Bool;
  isAlphanum = { Char# x -> isTrue# (is_alphanum x) };

  isWhiteSpace : Char -> Bool;
  isWhiteSpace =
    { Char# ' '# -> True
    | Char# '\n'# -> True
    | Char# '\r'# -> True
    | Char# '\t'# -> True
    | _ -> False
    };

  foreign import atoi : String# -> Int32#;

  const : a -> b -> a;
  const = { a _ -> a }; 

  type Parser r a = (a -> String -> Maybe (r, String)) -> String -> Maybe (r, String);

  item : Parser r Char;
  item = { k inp ->
    (headString inp, tailString inp)
    |> { (Nothing, _) -> Nothing
       | (Just c, cs) -> k c cs
       }
  };

  sat : (Char -> Bool) -> Parser r Char;
  sat = { p k ->
    with c = item; 
    if (p c) { k c } { const Nothing }
  };

  fail : Parser r a;
  fail = { _ -> const Nothing };

  digit : Parser r Int32;
  digit = { k ->
    with d = sat isDigit;
    k (subInt32 (ord d) (ord '0'))
  };

  lower : Parser r Char;
  lower = sat isLower;

  alphanum : Parser r Char;
  alphanum = sat isAlphanum;

  type Cont r a = (a -> r) -> r;
  mapCont : (a -> b) -> Cont r a -> Cont r b;
  mapCont = { f p k ->
    with x = p;
    k (f x)
  };

  mapParser : (a -> b) -> Parser r a -> Parser r b;
  mapParser = { f p k ->
    with x = p;
    k (f x)
  };

  char : Char -> Parser r ();
  char = { x -> mapParser { _ -> () } (sat (eqChar x)) };

  infixl 3 (<|>);
  (<|>) : Parser r a -> Parser r a -> Parser r a;
  (<|>) = { p q k inp ->
    p { x cs -> k x cs } inp -- pが成功すればkを実行する
    |> { Nothing -> q k inp -- pが失敗すればq kを実行する
       | Just (x, cs) -> Just (x, cs) } -- kの実行結果はそのまま返す
  };

  many : Parser r a -> Parser r (List a);
  many = { p ->
    { k -> with x = p;
           with xs = many p;
           k (Cons x xs)
    } <|> { k -> k Nil }
  };

  some : Parser r a -> Parser r (List a);
  some = { p ->
    { k -> with x = p;
           with xs = many p;
           k (Cons x xs)
    }
  };

  ident : Parser r String;
  ident = { k ->
    with c = lower;
    with cs = many alphanum;
    k (listToString (Cons c cs))
  };

  nat : Parser r Int32;
  nat = { k ->
    with ds = some digit;
    let shiftAdd = { m n -> addInt32 (mulInt32 10 m) n};
    k (foldl shiftAdd 0 ds)
  };

  main : { () };
  main = { 
    let src = getContents ();
    let parser = { k ->
      with x = nat;
      k x
    };

    parser { a cs -> Just (a, cs) } src
      |> { Nothing -> putStrLn "Nothing"
         | Just (x, cs) -> putStrLn (toStringInt32 x); putStrLn cs };

    ()
  };
}
