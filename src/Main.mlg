module Main = {
  module {..} = import Builtin;
  module {..} = import Prelude;

  ---------------
  -- Utilities --
  ---------------

  -- identity function
  identity : a -> a;
  identity = { x -> x };

  -- evaluate to `a` for all inputs
  const : a -> b -> a;
  const = { a _ -> a }; 

  -- optional value
  data Maybe a = Nothing | Just a;

  -- fold left
  foldl : (a -> b -> a) -> a -> List b -> a;
  foldl =
    { _ z Nil -> z
    | f z (Cons x xs) -> foldl f (f z x) xs
    };

  -- ascii code of a given character
  foreign import char_ord : Char# -> Int32#;

  ord : Char -> Int32;
  ord = { Char# c -> Int32# (char_ord c) };

  -- multiway if
  cond : List (Bool, {a}) -> a;
  cond =
    { Nil -> panic "no branch"
    | Cons (True, x) _ -> !x
    | Cons (False, _) xs -> cond xs
    };

  -- map function over a list
  mapList : (a -> b) -> List a -> List b;
  mapList =
    { _ Nil -> Nil
    | f (Cons x xs) -> Cons (f x) (mapList f xs)
    };

  -- concat a character and a string
  foreign import string_cons : Char# -> String# -> String#;

  stringCons : Char -> String -> String;
  stringCons = { (Char# c) (String# str) -> String# (string_cons c str) };

  -- convert a list of character to a string
  listToString : List Char -> String;
  listToString =
    { Nil -> ""
    | Cons c cs -> stringCons c (listToString cs)
    };

  -- get the first character of string
  headString : String -> Maybe Char;
  headString = { str ->
    if (eqString str "")
      { Nothing }
      { Just (atString 0L str) }
  };

  -- trim the first character of string
  tailString : String -> String;
  tailString = { str ->
    if (eqString str "")
      { str }
      { substring str 1L (lengthString str) }
  };

  -- return the longest prefix of `str` of that satisfy `pred`
  takeWhileString = { pred str ->
    headString str
      |> { Nothing -> str
         | Just c ->
             if (pred c)
               { stringCons c (takeWhileString pred (tailString str)) }
               { "" }
      }
  };

  -- return the suffix remains after `takeWhileString pred str`
  dropWhileString = { pred str ->
    headString str
      |> { Nothing -> str
         | Just c ->
             if (pred c)
               { dropWhileString pred (tailString str) }
               { str }
      }
  };

  infixr 6 (<>);
  (<>) : String -> String -> String;
  (<>) = appendString; 

  concat : List String -> String;
  concat =
    { Nil -> ""
    | Cons x xs -> x <> concat xs
    };

  punctuate : a -> List a -> List a;
  punctuate =
    { _ Nil -> Nil
    | _ (Cons x Nil) -> Cons x Nil
    | sep (Cons x xs) -> Cons x (Cons sep (punctuate sep xs))
    };

  -- check that `x` s match [0-9]
  foreign import is_digit : Char# -> Int32#;
  isDigit : Char -> Bool;
  isDigit = { Char# x -> isTrue# (is_digit x) };

  -- check that `x` s match [a-z]
  foreign import is_lower : Char# -> Int32#;
  isLower : Char -> Bool;
  isLower = { Char# x -> isTrue# (is_lower x) };

  -- check that `x` s match [A-Z]
  foreign import is_upper : Char# -> Int32#;
  isUpper : Char -> Bool;
  isUpper = { Char# x -> isTrue# (is_upper x) };

  -- check that `x` s match [a-zA-Z0-9]
  foreign import is_alphanum : Char# -> Int32#;
  isAlphanum : Char -> Bool;
  isAlphanum = { Char# x -> isTrue# (is_alphanum x) };

  -- check that `x` is a whitespace
  isWhiteSpace : Char -> Bool;
  isWhiteSpace =
    { Char# ' '# -> True
    | Char# '\n'# -> True
    | Char# '\r'# -> True
    | Char# '\t'# -> True
    | _ -> False
    };

  ------------
  -- Parser --
  ------------

  -- parser that written in CPS
  type Parser r a = (a -> String -> Maybe (r, String)) -> String -> Maybe (r, String);

  -- single character
  item : Parser r Char;
  item = { k inp ->
    (headString inp, tailString inp)
    |> { (Nothing, _) -> Nothing
       | (Just c, cs) -> k c cs
       }
  };

  -- a character that satisfy `p`
  sat : (Char -> Bool) -> Parser r Char;
  sat = { p k ->
    with c = item; 
    if (p c) { k c } { const Nothing }
  };

  -- give up parsing
  fail : Parser r a;
  fail = { _ -> const Nothing };

  -- [0-9]
  digit : Parser r Char;
  digit = sat isDigit;

  digitToInt : Char -> Int32;
  digitToInt = { d -> subInt32 (ord d) (ord '0') };

  -- [a-z]
  lower : Parser r Char;
  lower = sat isLower;

  -- [A-Z]
  upper : Parser r Char;
  upper = sat isUpper;

  -- alphabet or digit
  alphanum : Parser r Char;
  alphanum = sat isAlphanum;

  -- map function over a parser
  mapParser : (a -> b) -> Parser r a -> Parser r b;
  mapParser = { f p k ->
    with x = p;
    k (f x)
  };

  -- expect the character `x`
  char : Char -> Parser r Char;
  char = { x -> sat (eqChar x) };

  -- choice operator
  infixl 3 (<|>);
  (<|>) : Parser r a -> Parser r a -> Parser r a;
  (<|>) = { p q k inp ->
    p { x cs -> k x cs } inp -- pが成功すればkを実行する
    |> { Nothing -> q k inp -- pが失敗すればq kを実行する
       | Just (x, cs) -> Just (x, cs) } -- kの実行結果はそのまま返す
  };

  -- try `p` zero or more times
  many : Parser r a -> Parser r (List a);
  many = { p ->
    { k -> with x = p;
           with xs = many p;
           k (Cons x xs)
    } <|> { k -> k Nil }
  };

  -- try `p` one or more times
  some : Parser r a -> Parser r (List a);
  some = { p ->
    { k -> with x = p;
           with xs = many p;
           k (Cons x xs)
    }
  };

  -- [a-z][a-zA-Z0-9]
  ident : Parser r String;
  ident = { k ->
    with c = lower;
    with cs = many alphanum;
    k (listToString (Cons c cs))
  };

  -- [0-9]+
  nat : Parser r Int32;
  nat = { k ->
    with ds = some (mapParser digitToInt digit);
    let shiftAdd = { m n -> addInt32 (mulInt32 10 m) n};
    k (foldl shiftAdd 0 ds)
  };

  -- -?[0-9]+
  int : Parser r Int32;
  int = { k ->
    let op = { k -> with _ = char '-'; k (subInt32 0) } <|> { k -> k identity };
    with f = op;
    with n = nat;
    k (f n)
  };

  -- skip some spaces
  space : Parser r ();
  space = { k ->
    with _ = many (sat isWhiteSpace);
    k ()
  };

  -- skip some spaces and execute `p`
  token = { p k ->
    with _ = space;
    with x = p;
    with _ = space;
    k x
  };

  ------------------
  -- s-expression --
  ------------------

  data SExpr = Symbol String
             | SInt Int32
             | SList (List SExpr);

  show : SExpr -> String;
  show =
    { Symbol str -> "Symbol " <> str
    | SInt int -> "SInt " <> toStringInt32 int
    | SList ss -> "SList [" <> concat (punctuate ", " (mapList show ss)) <> "]"
    };

  symbol : Parser r SExpr;
  symbol = token { k ->
    with x = lower <|> upper <|> char '_';
    with xs = many (lower <|> upper <|> digit <|> char '_');
    k (Symbol (listToString (Cons x xs)))
  };

  sint : Parser r SExpr;
  sint = mapParser SInt (token int);

  slist = { k ->
    with _ = token (char '(');
    with xs = many expr;
    with _ = token (char ')');
    k (SList xs)
  };

  expr = symbol <|> sint <|> slist;

  main : { () };
  main = { 
    let src = getContents ();
    let parser = expr;

    parser { a cs -> Just (a, cs) } src
      |> { Nothing -> putStrLn "Nothing"
         | Just (x, cs) -> putStrLn "parsed:"; putStrLn (show x); putStrLn "rest:"; putStrLn cs };

    ()
  };
}
