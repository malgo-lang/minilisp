module Main = {
  module {..} = import Builtin;
  module {..} = import Prelude;

  data Maybe a = Nothing | Just a;

  foreign import string_cons : Char# -> String# -> String#;

  stringCons : Char -> String -> String;
  stringCons = { (Char# c) (String# str) -> String# (string_cons c str) };

  listToString : List Char -> String;
  listToString =
    { Nil -> ""
    | Cons c cs -> stringCons c (listToString cs)
    };

  type Parser a = String -> Maybe (a, String);

  parse : Parser a -> String -> Maybe (a, String);
  parse = { p input -> p input };

  return : a -> Parser a;
  return = { x inp -> Just (x, inp) };

  then : (a -> Parser b) -> Maybe (a, String) -> Maybe (b, String);
  then = { _ Nothing -> Nothing
         | f (Just (x, inp)) -> f x inp };

  map : (a -> b) -> Parser a -> Parser b;
  map = { g p ->
    { inp -> parse p inp
      |> { Nothing -> Nothing
         | Just (v, out) -> Just (g v, out) }
    }
  };

  infixl 4 (<*>);
  (<*>) = { pg px ->
    { inp -> parse pg inp
      |> { Nothing -> Nothing
         | Just (g, out) -> parse (map g px) out }
    }
  };

  infixl 1 (>>=);
  (>>=) : Parser a -> (a -> Parser b) -> Parser b;
  (>>=) = { p f ->
    { inp -> parse p inp
      |> { Nothing -> Nothing
         | Just (v, out) -> parse (f v) out }
    }
  };

  infixl 3 (<|>);
  (<|>) = { p q ->
    { inp -> parse p inp
      |> { Nothing -> parse q inp
         | Just (v, out) -> Just (v, out) }
    }
  };

  many : Parser a -> Parser (List a);
  many = { x -> some x <|> return Nil };

  defer : { a -> b } -> a -> b;
  defer = { f x -> !f x };

  some : Parser a -> Parser (List a);
  some = { x -> return Cons <*> x <*> defer { many x } };

  item : Parser Char;
  item = { inp ->
    if (eqString inp "")
      { Nothing }
      { Just (atString 0L inp, substring inp 1L (lengthString inp)) }
  };

  fail : Parser a;
  fail = { _ -> Nothing };

  sat : (Char -> Bool) -> Parser Char;
  sat = { p inp ->
    item inp |> then { c inp -> if (p c) { Just (c, inp) } { Nothing } }
  };

  foreign import is_digit : Char# -> Int32#;
  isDigit : Char -> Bool;
  isDigit = { Char# x -> isTrue# (is_digit x) };

  digit : Parser Char;
  digit = sat isDigit;

  foreign import is_lower : Char# -> Int32#;
  isLower : Char -> Bool;
  isLower = { Char# x -> isTrue# (is_lower x) };

  lower : Parser Char;
  lower = sat isLower;

  foreign import is_alphanum : Char# -> Int32#;
  isAlphanum : Char -> Bool;
  isAlphanum = { Char# x -> isTrue# (is_alphanum x) };

  alphanum : Parser Char;
  alphanum = sat isAlphanum;

  char : Char -> Parser ();
  char = { x -> map { _ -> () } (sat (eqChar x)) };

  ident : Parser String;
  ident = lower >>=
    { x -> many alphanum >>=
    { xs -> return (listToString (Cons x xs)) } };

  foreign import atoi : String# -> Int32#;

  nat : Parser Int32;
  nat = map listToString (some digit) >>=
    { String# x -> return (Int32# (atoi x)) };

  space : Parser ();
  space = many (sat { Char# ' '# -> True | _ -> False }) >>=
    { _ -> return () };

  token : Parser a -> Parser a;
  token = { p -> 
    space
    >>= { _ -> p 
    >>= { v -> map { _ -> v } space } }
  };

  main : { () };
  main = { 
    let src = getContents ();
    parse (token nat >>= { _ -> token ident }) src 
      |> { Nothing -> putStrLn "no valid input"
         | Just (_, rest) -> putStrLn rest }
  };
}
