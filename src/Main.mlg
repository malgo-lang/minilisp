module Main = {
  module {..} = import Builtin;
  module {..} = import Prelude;

  id : a -> a;
  id = { x -> x };

  cond : List (Bool, {a}) -> a;
  cond =
    { Nil -> panic "no branch"
    | Cons (True, x) _ -> !x
    | Cons (False, _) xs -> cond xs
    };

  mapList : (a -> b) -> List a -> List b;
  mapList =
    { _ Nil -> Nil
    | f (Cons x xs) -> Cons (f x) (mapList f xs)
    };

  data Maybe a = Nothing | Just a;

  foreign import string_cons : Char# -> String# -> String#;

  stringCons : Char -> String -> String;
  stringCons = { (Char# c) (String# str) -> String# (string_cons c str) };

  listToString : List Char -> String;
  listToString =
    { Nil -> ""
    | Cons c cs -> stringCons c (listToString cs)
    };

  headString : String -> Maybe Char;
  headString = { str ->
    if (eqString str "")
      { Nothing }
      { Just (atString 0L str) }
  };

  tailString : String -> String;
  tailString = { str ->
    if (eqString str "")
      { str }
      { substring str 1L (lengthString str) }
  };

  takeWhileString = { pred str ->
    headString str
      |> { Nothing -> str
         | Just c ->
             if (pred c)
               { stringCons c (takeWhileString pred (tailString str)) }
               { "" }
      }
  };

  dropWhileString = { pred str ->
    headString str
      |> { Nothing -> str
         | Just c ->
             if (pred c)
               { dropWhileString pred (tailString str) }
               { str }
      }
  };

  foreign import is_digit : Char# -> Int32#;
  isDigit : Char -> Bool;
  isDigit = { Char# x -> isTrue# (is_digit x) };

  foreign import is_lower : Char# -> Int32#;
  isLower : Char -> Bool;
  isLower = { Char# x -> isTrue# (is_lower x) };

  foreign import is_alphanum : Char# -> Int32#;
  isAlphanum : Char -> Bool;
  isAlphanum = { Char# x -> isTrue# (is_alphanum x) };

  isWhiteSpace : Char -> Bool;
  isWhiteSpace =
    { Char# ' '# -> True
    | Char# '\n'# -> True
    | Char# '\r'# -> True
    | Char# '\t'# -> True
    | _ -> False
    };

  foreign import atoi : String# -> Int32#;

  const : a -> b -> a;
  const = { a _ -> a }; 

  type Parser r a = (a -> String -> Maybe (r, String)) -> String -> Maybe (r, String);

  item : Parser r Char;
  item = { k inp ->
    (headString inp, tailString inp)
    |> { (Nothing, _) -> Nothing
       | (Just c, cs) -> k c cs
       }
  };

  sat : (Char -> Bool) -> Parser r Char;
  sat = { p k ->
    with c = item; 
    if (p c) { k c } { const Nothing }
  };

  fail : Parser r a;
  fail = { _ -> const Nothing };

  digit : Parser r Char;
  digit = sat isDigit;

  lower : Parser r Char;
  lower = sat isLower;

  alphanum : Parser r Char;
  alphanum = sat isAlphanum;

  type Cont r a = (a -> r) -> r;
  mapCont : (a -> b) -> Cont r a -> Cont r b;
  mapCont = { f p k ->
    with x = p;
    k (f x)
  };

  mapParser : (a -> b) -> Parser r a -> Parser r b;
  mapParser = { f p k ->
    with x = p;
    k (f x)
  };

  char : Char -> Parser r ();
  char = { x -> mapParser { _ -> () } (sat (eqChar x)) };

  infixl 3 (<|>);
  (<|>) : Parser r a -> Parser r a -> Parser r a;
  (<|>) = { p q k inp ->
    p { x cs -> k x cs } inp -- pが成功すればkを実行する
    |> { Nothing -> q k inp -- pが失敗すればq kを実行する
       | Just (x, cs) -> Just (x, cs) } -- kの実行結果はそのまま返す
  };

  many : Parser r a -> Parser r (List a);
  many = { p ->
    { k -> with x = p;
           with xs = many p;
           k (Cons x xs)
    } <|> { k -> k Nil }
  };

  ident : Parser r String;
  ident = { k ->
    with c = lower;
    with cs = many alphanum;
    k (listToString (Cons c cs))
  };

  main : { () };
  main = { 
    let src = getContents ();
    let parser = (
      with _ = char '4';
      with _ = char '2';
      ident
    );
    let parser = { k ->
      with _ = char '4';
      with _ = char '2';
      ident k 
    };

    parser { a cs -> Just (a, cs) } src |> { Nothing -> putStrLn "Nothing" | Just (_, cs) -> putStrLn cs };

    ()
  };
}
